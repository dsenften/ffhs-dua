= Heap Sort: Garantiert effizienter Sortieralgorithmus
:author: Daniel Senften
:revdate: {docdate}
:toc: left
:toclevels: 3
:encoding: utf-8
:toc-title: Inhaltsverzeichnis
:source-highlighter: highlight.js
:icons: font
:numbered:

== Einführung

Heap Sort ist ein effizienter, vergleichsbasierter Sortieralgorithmus, der auf der Heap-Datenstruktur basiert. Er wurde 1964 von J.W.J. Williams entwickelt und zeichnet sich durch seine garantierte Zeitkomplexität von O(n log n) in allen Fällen aus. Im Gegensatz zu Quick Sort hat Heap Sort keine ungünstigen Eingaben, die zu schlechterer Performance führen könnten.

=== Grundprinzip

Heap Sort arbeitet in zwei Hauptphasen:

1. **Heap-Konstruktion (Heapify)**: Das unsortierte Array wird in einen Max-Heap umgewandelt
2. **Sortdown**: Wiederholt wird das Maximum (Wurzel) extrahiert und an das Ende des Arrays gesetzt, dann wird die Heap-Eigenschaft wiederhergestellt

[IMPORTANT]
====
Ein **Max-Heap** ist ein vollständiger Binärbaum, bei dem jeder Knoten grösser oder gleich seinen Kindern ist. Die Wurzel enthält immer das Maximum.
====

== Die Heap-Datenstruktur

=== Definition

Ein Heap ist eine spezielle Baumdatenstruktur mit folgenden Eigenschaften:

* **Vollständiger Binärbaum**: Alle Ebenen sind vollständig gefüllt, ausser möglicherweise der letzten
* **Heap-Eigenschaft**: In einem Max-Heap ist jeder Knoten ≥ seinen Kindern
* **Array-Repräsentation**: Kann effizient als Array gespeichert werden

=== Array-Repräsentation

In der Array-Darstellung gilt für einen Knoten an Index `i`:

* **Linkes Kind**: Index `2*i + 1`
* **Rechtes Kind**: Index `2*i + 2`
* **Elternknoten**: Index `(i-1)/2` (abgerundet)

.Beispiel eines Max-Heaps
----
Array: [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]

Baum-Darstellung:
       16
     /    \
   14      10
  /  \    /  \
 8    7  9    3
/ \  /
2  4 1
----

== Algorithmus-Details

=== Sink-Operation (Heapify)

Die `sink`-Operation ist das Herzstück von Heap Sort. Sie stellt die Heap-Eigenschaft wieder her, indem ein Element so lange nach unten bewegt wird, bis es an der richtigen Position steht.

[source,python]
----
def sink(cls, arr: list, i: int, length: int) -> None:
    while 2 * i + 1 <= length:
        # Finde den Index des linken Kindes
        j = 2 * i + 1
        
        # Wähle das grössere der beiden Kinder
        if j < length and arr[j] < arr[j + 1]:
            j += 1
        
        # Wenn das aktuelle Element bereits grösser ist, sind wir fertig
        if arr[i] >= arr[j]:
            break
        
        # Tausche das aktuelle Element mit dem grösseren Kind
        arr[i], arr[j] = arr[j], arr[i]
        i = j
----

=== Heap-Konstruktion

Die Heap-Konstruktion beginnt mit dem letzten Nicht-Blatt-Knoten und arbeitet rückwärts:

[source,python]
----
# Phase 1: Heap-Konstruktion (Heapify)
n = len(arr)
k = n // 2 - 1  # Letzter Nicht-Blatt-Knoten
while k >= 0:
    sink(arr, k, n - 1)
    k -= 1
----

**Warum von hinten nach vorne?**
* Blatt-Knoten erfüllen automatisch die Heap-Eigenschaft
* Durch Rückwärts-Verarbeitung wird sichergestellt, dass Kinder bereits "heapified" sind

=== Sortdown-Phase

In der Sortdown-Phase wird wiederholt das Maximum extrahiert:

[source,python]
----
# Phase 2: Sortdown
while n > 1:
    # Tausche Maximum (Index 0) mit letztem Element
    arr[0], arr[n - 1] = arr[n - 1], arr[0]
    n -= 1
    # Stelle Heap-Eigenschaft für reduzierten Heap wieder her
    sink(arr, 0, n - 1)
----

== Komplexitätsanalyse

=== Zeitkomplexität

[cols="2,3,4"]
|===
|Phase |Komplexität |Beschreibung

|**Heap-Konstruktion**
|O(n)
|Überraschenderweise linear, nicht O(n log n)

|**Sortdown**
|O(n log n)
|n-1 Extraktionen, jede kostet O(log n)

|**Gesamt**
|O(n log n)
|In allen Fällen: Best, Average, Worst Case
|===

=== Detaillierte Analyse der Heap-Konstruktion

Die Heap-Konstruktion ist tatsächlich O(n), nicht O(n log n):

----
Anzahl Knoten auf Ebene h: ≤ ⌈n/2^(h+1)⌉
Maximale Sink-Distanz: h

Gesamtkosten: Σ(h=0 bis log n) ⌈n/2^(h+1)⌉ * h
            = O(n * Σ(h=0 bis ∞) h/2^h)
            = O(n * 2) = O(n)
----

=== Speicherkomplexität

* **Speicherplatz**: O(1) - In-Place-Sortierung
* **Zusätzlicher Speicher**: Nur konstanter Speicher für Variablen
* **Stack-Speicher**: O(1) - Keine Rekursion

== Eigenschaften

=== Stabilität

[WARNING]
====
Heap Sort ist **nicht stabil**. Gleiche Elemente können ihre relative Reihenfolge ändern.
====

.Beispiel für Instabilität
[source,python]
----
# Eingabe: [(3,a), (1,b), (3,c), (2,d)]
# Mögliche Ausgabe: [(1,b), (2,d), (3,c), (3,a)]
# Die Reihenfolge der 3er hat sich geändert!
----

=== In-Place Sortierung

Heap Sort sortiert das Array direkt ohne zusätzlichen Speicher für die Daten.

=== Adaptive Eigenschaften

Heap Sort ist **nicht adaptiv** - die Laufzeit ist unabhängig von der Vorsortierung der Eingabe.

=== Konsistente Performance

**Grosser Vorteil**: Heap Sort hat in allen Fällen O(n log n) Zeitkomplexität:
* Bereits sortierte Arrays: O(n log n)
* Umgekehrt sortierte Arrays: O(n log n)  
* Zufällige Arrays: O(n log n)

== Implementierung

=== Vollständige Klasse

[source,python]
----
class Heap:
    """Heap-Sort-Implementierung.

    Diese Klasse bietet Methoden zum Sortieren von Listen mit dem Heap-Sort-Algorithmus
    und zum Überprüfen, ob eine Liste sortiert ist.
    """

    @classmethod
    def sort(cls, arr: list) -> list:
        """Sortiert eine Liste mit dem Heap-Sort-Algorithmus.

        Args:
            arr: Die zu sortierende Liste.

        Returns:
            Die sortierte Liste (in-place modifiziert).
        """
        n = len(arr)
        
        # Phase 1: Heap-Konstruktion
        k = n // 2 - 1
        while k >= 0:
            cls.sink(arr, k, n - 1)
            k -= 1

        # Phase 2: Sortdown
        while n > 1:
            arr[0], arr[n - 1] = arr[n - 1], arr[0]
            n -= 1
            cls.sink(arr, 0, n - 1)

        return arr

    @classmethod
    def is_sorted(cls, arr: list) -> bool:
        """Überprüft, ob eine Liste sortiert ist."""
        for i in range(1, len(arr)):
            if arr[i] < arr[i - 1]:
                return False
        return True
----

=== Verwendung

[source,python]
----
from src.algs4.sorting.heap import Heap

# Beispiel 1: Ganzzahlen sortieren
numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = Heap.sort(numbers)
print(sorted_numbers)  # [11, 12, 22, 25, 34, 64, 90]

# Beispiel 2: Strings sortieren
words = ["banana", "apple", "cherry", "date"]
sorted_words = Heap.sort(words)
print(sorted_words)  # ['apple', 'banana', 'cherry', 'date']

# Beispiel 3: Überprüfung der Sortierung
is_sorted = Heap.is_sorted([1, 2, 3, 4, 5])
print(is_sorted)  # True
----

== Vergleich mit anderen Sortieralgorithmen

[cols="2,2,2,2,2,2"]
|===
|Algorithmus |Best Case |Average Case |Worst Case |Speicher |Stabil

|**Heap Sort**
|O(n log n)
|O(n log n)
|O(n log n)
|O(1)
|❌

|**Quick Sort**
|O(n log n)
|O(n log n)
|O(n²)
|O(log n)
|❌

|**Merge Sort**
|O(n log n)
|O(n log n)
|O(n log n)
|O(n)
|✅

|**Shell Sort**
|O(n log n)
|O(n^1.25)
|O(n²)
|O(1)
|❌

|**Insertion Sort**
|O(n)
|O(n²)
|O(n²)
|O(1)
|✅
|===

=== Wann Heap Sort verwenden?

**Vorteile:**
* Garantierte O(n log n) Performance in allen Fällen
* In-Place Sortierung (konstanter Speicherverbrauch)
* Keine Rekursion (kein Stack Overflow-Risiko)
* Vorhersagbare Performance

**Nachteile:**
* Nicht stabil
* Schlechtere Cache-Lokalität als Quick Sort
* Konstante Faktoren höher als Quick Sort im Durchschnitt

**Empfehlung:**
Heap Sort ist ideal, wenn:
* Worst-Case-Garantien wichtig sind
* Speicherverbrauch minimiert werden muss
* Konsistente Performance erforderlich ist
* Stabilität nicht benötigt wird

== Heap-Anwendungen

=== Priority Queue

Heaps sind die Grundlage für Priority Queues:

[source,python]
----
class PriorityQueue:
    def __init__(self):
        self.heap = []
    
    def insert(self, item):
        self.heap.append(item)
        self._swim(len(self.heap) - 1)
    
    def extract_max(self):
        if not self.heap:
            return None
        
        max_item = self.heap[0]
        self.heap[0] = self.heap[-1]
        self.heap.pop()
        
        if self.heap:
            self._sink(0)
        
        return max_item
----

=== Heap Select (Top-K Problem)

Finde die k grössten Elemente ohne vollständige Sortierung:

[source,python]
----
def heap_select(arr, k):
    """Finde die k grössten Elemente."""
    # Baue Heap
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        sink(arr, i, n - 1)
    
    # Extrahiere k Maxima
    result = []
    for _ in range(min(k, n)):
        result.append(arr[0])
        arr[0], arr[n - 1] = arr[n - 1], arr[0]
        n -= 1
        if n > 0:
            sink(arr, 0, n - 1)
    
    return result
----

== Optimierungen

=== Bottom-Up Heap-Konstruktion

Die Standard-Implementierung kann durch "Bottom-Up" Heapify optimiert werden:

[source,python]
----
def bottom_up_heapify(arr):
    """Optimierte Heap-Konstruktion."""
    n = len(arr)
    
    # Beginne mit Blättern und arbeite nach oben
    for i in range(n // 2 - 1, -1, -1):
        # Finde korrekte Position ohne Tauschen
        parent = i
        child = 2 * parent + 1
        
        while child < n:
            # Wähle grösseres Kind
            if child + 1 < n and arr[child] < arr[child + 1]:
                child += 1
            
            # Wenn Heap-Eigenschaft erfüllt, fertig
            if arr[parent] >= arr[child]:
                break
            
            # Tausche und gehe weiter nach unten
            arr[parent], arr[child] = arr[child], arr[parent]
            parent = child
            child = 2 * parent + 1
----

=== Ternärer Heap

Für bessere Cache-Performance kann ein ternärer Heap verwendet werden:

[source,python]
----
def ternary_sink(arr, i, n):
    """Sink-Operation für ternären Heap (3 Kinder pro Knoten)."""
    while 3 * i + 1 < n:
        # Finde grösstes der drei Kinder
        max_child = 3 * i + 1
        
        for j in range(2, 4):  # Prüfe die anderen beiden Kinder
            child_idx = 3 * i + j
            if child_idx < n and arr[child_idx] > arr[max_child]:
                max_child = child_idx
        
        if arr[i] >= arr[max_child]:
            break
        
        arr[i], arr[max_child] = arr[max_child], arr[i]
        i = max_child
----

== Anwendungsbeispiele

=== Beispiel 1: Medianfindung

[source,python]
----
def find_median_heap(arr):
    """Finde den Median mit Heap Sort."""
    sorted_arr = Heap.sort(arr.copy())
    n = len(sorted_arr)
    
    if n % 2 == 1:
        return sorted_arr[n // 2]
    else:
        mid1, mid2 = sorted_arr[n // 2 - 1], sorted_arr[n // 2]
        return (mid1 + mid2) / 2

# Beispiel
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
median = find_median_heap(numbers)
print(f"Median: {median}")  # 3.5
----

=== Beispiel 2: Event-Scheduling

[source,python]
----
class Event:
    def __init__(self, time, description):
        self.time = time
        self.description = description
    
    def __lt__(self, other):
        return self.time < other.time
    
    def __repr__(self):
        return f"Event({self.time}, '{self.description}')"

# Events nach Zeit sortieren
events = [
    Event(10, "Meeting"),
    Event(5, "Lunch"),
    Event(15, "Presentation"),
    Event(8, "Call")
]

sorted_events = Heap.sort(events)
print("Chronologische Reihenfolge:")
for event in sorted_events:
    print(f"{event.time}: {event.description}")
----

=== Beispiel 3: Performance-Vergleich

[source,python]
----
import time
import random

def benchmark_sorting_algorithms(size):
    """Vergleiche Performance verschiedener Sortieralgorithmen."""
    # Generiere Testdaten
    data = [random.randint(1, 1000) for _ in range(size)]
    
    algorithms = [
        ("Heap Sort", Heap.sort),
        ("Quick Sort", Quick.sort),
        ("Shell Sort", Shell.sort),
        ("Python sorted", sorted)
    ]
    
    results = {}
    
    for name, algorithm in algorithms:
        test_data = data.copy()
        start_time = time.time()
        
        if name == "Python sorted":
            result = algorithm(test_data)
        else:
            result = algorithm(test_data)
        
        end_time = time.time()
        results[name] = end_time - start_time
    
    return results

# Teste verschiedene Grössen
for size in [1000, 5000, 10000]:
    print(f"\nArray-Grösse: {size}")
    results = benchmark_sorting_algorithms(size)
    
    for algorithm, time_taken in results.items():
        print(f"{algorithm}: {time_taken:.4f} Sekunden")
----

== Heap Sort Varianten

=== Min-Heap Sort (absteigende Sortierung)

[source,python]
----
class MinHeap:
    @classmethod
    def sink(cls, arr, i, length):
        """Sink-Operation für Min-Heap."""
        while 2 * i + 1 <= length:
            j = 2 * i + 1
            
            # Wähle das kleinere der beiden Kinder
            if j < length and arr[j] > arr[j + 1]:
                j += 1
            
            if arr[i] <= arr[j]:
                break
            
            arr[i], arr[j] = arr[j], arr[i]
            i = j
    
    @classmethod
    def sort_descending(cls, arr):
        """Sortiert absteigend mit Min-Heap."""
        n = len(arr)
        
        # Baue Min-Heap
        k = n // 2 - 1
        while k >= 0:
            cls.sink(arr, k, n - 1)
            k -= 1
        
        # Extrahiere Minima (für absteigende Sortierung)
        while n > 1:
            arr[0], arr[n - 1] = arr[n - 1], arr[0]
            n -= 1
            cls.sink(arr, 0, n - 1)
        
        return arr
----

=== Iterative vs. Rekursive Implementierung

Unsere Implementierung ist bereits iterativ, was Stack Overflow verhindert:

[source,python]
----
# Rekursive Variante (nicht empfohlen für grosse Arrays)
def recursive_sink(arr, i, length):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left <= length and arr[left] > arr[largest]:
        largest = left
    
    if right <= length and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        recursive_sink(arr, largest, length)
----

== Häufige Fehlerquellen

=== 1. Falsche Array-Indizierung

**Problem**: Verwechslung zwischen 0-basierter und 1-basierter Indizierung.

[source,python]
----
# FALSCH - 1-basierte Formeln in 0-basiertem Array
left_child = 2 * i      # Sollte 2 * i + 1 sein
right_child = 2 * i + 1 # Sollte 2 * i + 2 sein

# RICHTIG - 0-basierte Formeln
left_child = 2 * i + 1
right_child = 2 * i + 2
parent = (i - 1) // 2
----

=== 2. Heap-Grösse vs. Array-Grösse

**Problem**: Verwechslung zwischen aktueller Heap-Grösse und Array-Länge.

[source,python]
----
# FALSCH - verwendet Array-Länge statt Heap-Grösse
while 2 * i + 1 < len(arr):  # Sollte <= length sein

# RICHTIG - verwendet aktuelle Heap-Grösse
while 2 * i + 1 <= length:
----

=== 3. Off-by-One Fehler

**Problem**: Falsche Grenzen bei Schleifen und Indizes.

[source,python]
----
# FALSCH - startet bei falschem Index
k = n // 2  # Sollte n // 2 - 1 sein

# RICHTIG - letzter Nicht-Blatt-Knoten
k = n // 2 - 1
----

== Zusammenfassung

Heap Sort ist ein robuster und vorhersagbarer Sortieralgorithmus mit einzigartigen Eigenschaften:

**Kernpunkte:**
* Garantierte O(n log n) Zeitkomplexität in allen Fällen
* O(1) Speicherkomplexität durch In-Place-Sortierung
* Basiert auf der eleganten Heap-Datenstruktur
* Nicht stabil, aber konsistent performant
* Ideal für Systeme mit strengen Worst-Case-Anforderungen

**Anwendungsbereiche:**
* Eingebettete Systeme mit Speicherbeschränkungen
* Real-Time-Systeme mit Performance-Garantien
* Priority Queues und Event-Scheduling
* Situationen, wo Worst-Case-Performance kritisch ist

Die Implementierung in diesem Projekt bietet eine vollständige, gut dokumentierte und getestete Heap-Sort-Lösung, die sowohl für Lernzwecke als auch für praktische Anwendungen geeignet ist.
