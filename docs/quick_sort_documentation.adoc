= Quick Sort: Effizienter Divide-and-Conquer-Sortieralgorithmus
:author: Daniel Senften
:revdate: {docdate}
:toc: left
:toclevels: 3
:encoding: utf-8
:toc-title: Inhaltsverzeichnis
:source-highlighter: highlight.js
:icons: font
:numbered:

== Einführung

Quick Sort ist einer der wichtigsten und am häufigsten verwendeten Sortieralgorithmen in der Informatik. Er wurde 1960 von Tony Hoare entwickelt und basiert auf dem Divide-and-Conquer-Prinzip. Quick Sort zeichnet sich durch seine durchschnittlich sehr gute Performance von O(n log n) aus und wird in vielen Standard-Bibliotheken als Standard-Sortieralgorithmus verwendet.

=== Grundprinzip

Quick Sort funktioniert nach dem Divide-and-Conquer-Prinzip:

1. **Divide**: Wähle ein Element als *Pivot* und partitioniere das Array so, dass alle Elemente kleiner als das Pivot links und alle grösseren Elemente rechts davon stehen
2. **Conquer**: Sortiere rekursiv die beiden Teilarrays links und rechts vom Pivot
3. **Combine**: Da die Partitionierung bereits die richtige Reihenfolge gewährleistet, ist keine weitere Kombination nötig

[IMPORTANT]
====
Der Schlüssel zu Quick Sorts Effizienz liegt in der *Partitionierung*. Eine gute Pivot-Wahl führt zu ausgewogenen Teilproblemen und optimaler Performance.
====

== Algorithmus-Details

=== Partitionierung (Hoare-Schema)

Die Partitionierung ist das Herzstück von Quick Sort. Unsere Implementierung verwendet das klassische Hoare-Partitionierungsschema:

[source,python]
----
def partition(cls, arr: list, lo: int, hi: int) -> int:
    # Wähle das erste Element als Pivot
    v = arr[lo]
    i = lo
    j = hi + 1
    
    while True:
        # Finde Element von links, das >= Pivot ist
        while True:
            i += 1
            if not (i < hi and arr[i] < v):
                break
        
        # Finde Element von rechts, das <= Pivot ist
        while True:
            j -= 1
            if not (j > lo and arr[j] > v):
                break
        
        # Überprüfe, ob sich die Zeiger gekreuzt haben
        if i >= j:
            break
        
        # Tausche Elemente
        arr[i], arr[j] = arr[j], arr[i]

    # Setze Pivot an die richtige Position
    arr[lo], arr[j] = arr[j], arr[lo]
    return j
----

=== Rekursive Sortierung

[source,python]
----
def quicksort(cls, arr: list, lo: int, hi: int) -> list:
    if lo >= hi:
        return arr

    # Partitioniere das Array und erhalte die Pivot-Position
    j = cls.partition(arr, lo, hi)
    
    # Sortiere rekursiv die beiden Teilarrays
    cls.quicksort(arr, lo, j - 1)
    cls.quicksort(arr, j + 1, hi)
    
    return arr
----

== Komplexitätsanalyse

=== Zeitkomplexität

[cols="2,3,4"]
|===
|Fall |Komplexität |Beschreibung

|**Best Case**
|O(n log n)
|Pivot teilt das Array immer in zwei gleich grosse Hälften

|**Average Case**
|O(n log n)
|Pivot teilt das Array in etwa gleich grosse Teile

|**Worst Case**
|O(n²)
|Pivot ist immer das kleinste oder grösste Element (bereits sortierte Arrays)
|===

=== Speicherkomplexität

* **Speicherplatz**: O(log n) für den Rekursionsstack im Durchschnitt
* **Worst Case**: O(n) Speicher bei unausgewogener Rekursion
* **In-Place**: Ja, sortiert das Array direkt ohne zusätzlichen Speicher für die Daten

=== Detaillierte Analyse

==== Best Case: O(n log n)

Im besten Fall teilt das Pivot-Element das Array immer in zwei gleich grosse Hälften:

----
T(n) = 2T(n/2) + O(n)
----

Nach dem Master-Theorem ergibt sich: T(n) = O(n log n)

==== Worst Case: O(n²)

Der Worst Case tritt auf, wenn das Pivot immer das kleinste oder grösste Element ist:

----
T(n) = T(n-1) + O(n) = O(n²)
----

Dies passiert häufig bei:
* Bereits sortierten Arrays
* Umgekehrt sortierten Arrays
* Arrays mit vielen gleichen Elementen

==== Average Case: O(n log n)

Im Durchschnitt ist Quick Sort sehr effizient, da die Wahrscheinlichkeit für extreme Ungleichgewichte gering ist.

== Eigenschaften

=== Stabilität

[WARNING]
====
Quick Sort ist **nicht stabil**. Gleiche Elemente können ihre relative Reihenfolge ändern.
====

.Beispiel für Instabilität
[source,python]
----
# Eingabe: [(3,a), (1,b), (3,c), (2,d)]
# Mögliche Ausgabe: [(1,b), (2,d), (3,c), (3,a)]
# Die Reihenfolge der 3er hat sich geändert!
----

=== In-Place Sortierung

Quick Sort sortiert das Array direkt und benötigt nur O(log n) zusätzlichen Speicher für den Rekursionsstack.

=== Adaptive Eigenschaften

Quick Sort ist **nicht adaptiv** - die Laufzeit hängt nicht davon ab, wie vorsortiert die Eingabe bereits ist. Tatsächlich kann eine bereits sortierte Eingabe zum Worst Case führen.

== Implementierung

=== Vollständige Klasse

[source,python]
----
class Quick:
    """Quick-Sort-Implementierung.

    Diese Klasse bietet Methoden zum Sortieren von Listen mit dem Quick-Sort-Algorithmus
    und zum Überprüfen, ob eine Liste sortiert ist.
    """

    @classmethod
    def sort(cls, arr: list) -> list:
        """Sortiert eine Liste mit dem Quick-Sort-Algorithmus.

        Args:
            arr: Die zu sortierende Liste.

        Returns:
            Die sortierte Liste.
        """
        return cls.quicksort(arr, 0, len(arr) - 1)

    @classmethod
    def is_sorted(cls, arr: list) -> bool:
        """Überprüft, ob eine Liste sortiert ist.

        Args:
            arr: Die zu überprüfende Liste.

        Returns:
            True, wenn die Liste sortiert ist, sonst False.
        """
        for i in range(1, len(arr)):
            if arr[i] < arr[i - 1]:
                return False
        return True
----

=== Verwendung

[source,python]
----
from src.algs4.sorting.quick import Quick

# Beispiel 1: Ganzzahlen sortieren
numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = Quick.sort(numbers)
print(sorted_numbers)  # [11, 12, 22, 25, 34, 64, 90]

# Beispiel 2: Strings sortieren
words = ["banana", "apple", "cherry", "date"]
sorted_words = Quick.sort(words)
print(sorted_words)  # ['apple', 'banana', 'cherry', 'date']

# Beispiel 3: Überprüfung der Sortierung
is_sorted = Quick.is_sorted([1, 2, 3, 4, 5])
print(is_sorted)  # True
----

== Vergleich mit anderen Sortieralgorithmen

[cols="2,2,2,2,2"]
|===
|Algorithmus |Best Case |Average Case |Worst Case |Stabil

|**Quick Sort**
|O(n log n)
|O(n log n)
|O(n²)
|❌

|**Merge Sort**
|O(n log n)
|O(n log n)
|O(n log n)
|✅

|**Heap Sort**
|O(n log n)
|O(n log n)
|O(n log n)
|❌

|**Shell Sort**
|O(n log n)
|O(n^1.25)
|O(n²)
|❌

|**Insertion Sort**
|O(n)
|O(n²)
|O(n²)
|✅
|===

=== Wann Quick Sort verwenden?

**Vorteile:**
* Sehr schnell im Durchschnitt (O(n log n))
* In-Place Sortierung (geringer Speicherverbrauch)
* Einfach zu implementieren
* Cache-effizient durch lokale Speicherzugriffe

**Nachteile:**
* Worst-Case O(n²) Performance
* Nicht stabil
* Rekursive Implementierung kann bei grossen Arrays zu Stack Overflow führen

**Empfehlung:**
Quick Sort ist ideal für allgemeine Sortieraufgaben, wenn:
* Durchschnittliche Performance wichtiger ist als Worst-Case-Garantien
* Speicherverbrauch minimiert werden soll
* Stabilität nicht erforderlich ist

== Optimierungen

=== 1. Bessere Pivot-Wahl

**Median-of-Three**: Wähle den Median aus erstem, mittlerem und letztem Element als Pivot.

[source,python]
----
def median_of_three(arr, lo, hi):
    mid = (lo + hi) // 2
    if arr[mid] < arr[lo]:
        arr[lo], arr[mid] = arr[mid], arr[lo]
    if arr[hi] < arr[lo]:
        arr[lo], arr[hi] = arr[hi], arr[lo]
    if arr[hi] < arr[mid]:
        arr[mid], arr[hi] = arr[hi], arr[mid]
    return mid
----

=== 2. Cutoff für kleine Arrays

Für kleine Arrays (< 10 Elemente) ist Insertion Sort oft schneller:

[source,python]
----
CUTOFF = 10

def quicksort_optimized(arr, lo, hi):
    if hi <= lo + CUTOFF - 1:
        insertion_sort(arr, lo, hi)
        return
    # ... normale Quick Sort Logik
----

=== 3. Iterative Implementierung

Vermeidet Stack Overflow bei tiefer Rekursion:

[source,python]
----
def quicksort_iterative(arr):
    stack = [(0, len(arr) - 1)]
    
    while stack:
        lo, hi = stack.pop()
        if lo < hi:
            p = partition(arr, lo, hi)
            stack.append((lo, p - 1))
            stack.append((p + 1, hi))
----

== Anwendungsbeispiele

=== Beispiel 1: Sortierung von Studenten nach Noten

[source,python]
----
class Student:
    def __init__(self, name, grade):
        self.name = name
        self.grade = grade
    
    def __lt__(self, other):
        return self.grade < other.grade
    
    def __repr__(self):
        return f"{self.name}: {self.grade}"

students = [
    Student("Alice", 85),
    Student("Bob", 92),
    Student("Charlie", 78),
    Student("Diana", 96)
]

Quick.sort(students)
print(students)  # Charlie: 78, Alice: 85, Bob: 92, Diana: 96
----

=== Beispiel 2: Performance-Messung

[source,python]
----
import time
import random

def measure_performance(size):
    # Generiere zufällige Daten
    data = [random.randint(1, 1000) for _ in range(size)]
    
    start_time = time.time()
    Quick.sort(data.copy())
    end_time = time.time()
    
    return end_time - start_time

# Teste verschiedene Grössen
for size in [1000, 5000, 10000, 50000]:
    time_taken = measure_performance(size)
    print(f"Grösse {size}: {time_taken:.4f} Sekunden")
----

== Häufige Fehlerquellen

=== 1. Infinite Rekursion

**Problem**: Falsche Behandlung von Grenzfällen kann zu endloser Rekursion führen.

[source,python]
----
# FALSCH - kann zu endloser Rekursion führen
if lo < hi:  # Sollte lo >= hi sein für Abbruch
    return
----

=== 2. Array-Grenzen

**Problem**: Zugriff ausserhalb der Array-Grenzen bei der Partitionierung.

[source,python]
----
# FALSCH - kann über Array-Grenzen hinausgehen
while arr[i] < pivot:  # Keine Grenzprüfung
    i += 1
----

=== 3. Pivot-Positionierung

**Problem**: Falsches Setzen des Pivots nach der Partitionierung.

[source,python]
----
# FALSCH - Pivot wird nicht korrekt positioniert
return i  # Sollte nach Tausch mit Pivot erfolgen
----

== Zusammenfassung

Quick Sort ist ein mächtiger und vielseitiger Sortieralgorithmus, der durch seine durchschnittlich exzellente Performance von O(n log n) und seinen geringen Speicherverbrauch besticht. Obwohl er im Worst Case O(n²) Zeit benötigt und nicht stabil ist, macht ihn seine Einfachheit und Effizienz zu einer der beliebtesten Sortieralgorithmen in der Praxis.

**Kernpunkte:**
* Divide-and-Conquer-Algorithmus mit Partitionierung als Schlüsseloperation
* Durchschnittlich O(n log n), Worst Case O(n²)
* In-Place Sortierung mit O(log n) Speicherverbrauch
* Nicht stabil, aber sehr cache-effizient
* Ideal für allgemeine Sortieraufgaben ohne spezielle Anforderungen

Die Implementierung in diesem Projekt folgt dem klassischen Hoare-Partitionierungsschema und bietet eine solide Grundlage für das Verständnis und die Anwendung von Quick Sort in verschiedenen Kontexten.
