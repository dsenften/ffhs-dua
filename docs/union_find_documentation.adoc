= Union-Find (Disjoint-Set): Datenstruktur für dynamische Konnektivität
:author: Daniel Senften
:revdate: {docdate}
:toc: left
:toclevels: 3
:encoding: utf-8
:toc-title: Inhaltsverzeichnis
:source-highlighter: highlight.js
:icons: font
:numbered:

== Einführung

Union-Find, auch bekannt als Disjoint-Set-Datenstruktur, ist eine fundamentale Datenstruktur zur effizienten Verwaltung von disjunkten Mengen. Sie löst das Problem der _dynamischen Konnektivität_ – die Frage, ob zwei Elemente in derselben zusammenhängenden Komponente liegen.

=== Das Konnektivitätsproblem

Gegeben sei eine Menge von n Objekten (0 bis n-1). Wir können Verbindungen zwischen Objektpaaren erstellen und möchten effizient folgende Fragen beantworten:

* **Connected**: Sind p und q verbunden?
* **Union**: Verbinde p und q
* **Count**: Wie viele separate Komponenten gibt es?

[IMPORTANT]
====
Die "ist-verbunden-mit"-Relation muss eine **Äquivalenzrelation** sein:

* **Reflexiv**: p ist mit p verbunden
* **Symmetrisch**: Wenn p mit q verbunden ist, dann ist q mit p verbunden
* **Transitiv**: Wenn p mit q und q mit r verbunden ist, dann ist p mit r verbunden
====

=== Anwendungsbeispiele

Union-Find findet Anwendung in vielen Bereichen:

* **Netzwerk-Konnektivität**: Sind zwei Computer im gleichen Netzwerk erreichbar?
* **Bild-Segmentierung**: Welche Pixel gehören zum gleichen Objekt?
* **Labyrinth-Generierung**: Zufällige Pfade zwischen Räumen erstellen
* **Kruskal-Algorithmus**: Minimaler Spannbaum in Graphen
* **Perkolation**: Physikalische Durchlässigkeit von Materialien

== Theoretische Grundlagen

=== Mathematische Modellierung

Union-Find modelliert eine **Partitionierung** der Menge {0, 1, 2, ..., n-1} in disjunkte Teilmengen (Komponenten). Jede Komponente enthält alle miteinander verbundenen Elemente.

.Beispiel einer Partitionierung
----
Ursprünglich: {0}, {1}, {2}, {3}, {4}, {5}  // 6 Komponenten

Nach union(0,1): {0,1}, {2}, {3}, {4}, {5}  // 5 Komponenten
Nach union(2,3): {0,1}, {2,3}, {4}, {5}     // 4 Komponenten
Nach union(0,2): {0,1,2,3}, {4}, {5}        // 3 Komponenten
----

=== Komplexitätsanalyse-Übersicht

[cols="2,2,2,2,2"]
|===
|Implementation |Union |Find |Connected |Speicher

|Quick Find
|O(n)
|O(1)
|O(1)
|O(n)

|Quick Union
|O(n)*
|O(n)*
|O(n)*
|O(n)

|Weighted Quick Union
|O(log n)
|O(log n)
|O(log n)
|O(n)

|**Weighted QU + Path Compression**
|**O(α(n))**
|**O(α(n))**
|**O(α(n))**
|**O(n)**
|===

_*) Schlechtester Fall, α(n) ist die inverse Ackermann-Funktion_

== Implementierungen

=== 1. Quick Find

**Idee**: Direkte Speicherung der Komponenten-ID für jeden Knoten.

[source,python]
----
class QuickFindUF:
    def __init__(self, n):
        self._id = list(range(n))  # id[i] = Komponenten-ID von i
        self._count = n

    def find(self, p):
        return self._id[p]  # O(1) - direkter Zugriff

    def union(self, p, q):
        pid = self._id[p]
        qid = self._id[q]
        if pid == qid:
            return

        # Ändere alle Elemente mit pid zu qid
        for i in range(len(self._id)):  # O(n)
            if self._id[i] == pid:
                self._id[i] = qid

        self._count -= 1

    def connected(self, p, q):
        return self._id[p] == self._id[q]  # O(1)
----

**Vorteile**:
- find() und connected() in O(1)
- Einfache Implementierung

**Nachteile**:
- union() in O(n) - zu langsam für grosse Datenmengen
- N² Operationen für n-1 union-Aufrufe

=== 2. Quick Union

**Idee**: Baumstruktur, wo parent[i] der Elternknoten von i ist.

[source,python]
----
class QuickUnionUF:
    def __init__(self, n):
        self._parent = list(range(n))  # parent[i] = Eltern von i
        self._count = n

    def find(self, p):
        # Folge Zeigern bis zur Wurzel
        while p != self._parent[p]:  # O(Baumhöhe)
            p = self._parent[p]
        return p

    def union(self, p, q):
        root_p = self.find(p)
        root_q = self.find(q)
        if root_p == root_q:
            return

        # Hänge eine Wurzel unter die andere
        self._parent[root_p] = root_q  # O(1) nach find()
        self._count -= 1

    def connected(self, p, q):
        return self.find(p) == self.find(q)  # O(Baumhöhe)
----

**Problem**: Bäume können linear degenerieren (Worst Case O(n))

.Beispiel einer schlechten Baumstruktur
----
0 → 1 → 2 → 3 → 4  // Lineare Kette, find(4) braucht 4 Schritte
----

=== 3. Weighted Quick Union

**Idee**: Verhindere tiefe Bäume durch Gewichtung nach Baumgrösse.

[source,python]
----
class WeightedQuickUnionUF:
    def __init__(self, n):
        self._parent = list(range(n))
        self._size = [1] * n  # size[i] = Anzahl Elemente im Baum mit Wurzel i
        self._count = n

    def union(self, p, q):
        root_p = self.find(p)
        root_q = self.find(q)
        if root_p == root_q:
            return

        # Hänge kleineren Baum unter grösseren
        if self._size[root_p] < self._size[root_q]:
            small, large = root_p, root_q
        else:
            small, large = root_q, root_p

        self._parent[small] = large
        self._size[large] += self._size[small]
        self._count -= 1
----

**Verbesserung**: Baumhöhe ist maximal log₂(n), da sich die Baumgrösse mindestens verdoppelt, wenn die Höhe um 1 steigt.

=== 4. Weighted Quick Union + Path Compression

**Idee**: Kombiniere Gewichtung mit Pfad-Kompression für optimale Performance.

[source,python]
----
class UF:
    def __init__(self, n):
        self._parent = list(range(n))
        self._rank = [0] * n  # rank[i] ≈ Höhe des Baums mit Wurzel i
        self._count = n

    def find(self, p):
        while p != self._parent[p]:
            # Path Compression: Zeige auf Grosseltern
            self._parent[p] = self._parent[self._parent[p]]
            p = self._parent[p]
        return p

    def union(self, p, q):
        root_p = self.find(p)
        root_q = self.find(q)
        if root_p == root_q:
            return

        # Union by Rank: Hänge niedrigeren Rang unter höheren
        if self._rank[root_p] < self._rank[root_q]:
            self._parent[root_p] = root_q
        elif self._rank[root_p] > self._rank[root_q]:
            self._parent[root_q] = root_p
        else:
            self._parent[root_q] = root_p
            self._rank[root_p] += 1

        self._count -= 1
----

[NOTE]
====
**Path Compression Varianten**:

1. **Path Halving** (implementiert): Jeder Knoten zeigt auf seinen Grosseltern
2. **Path Splitting**: Jeder zweite Knoten zeigt auf seinen Grosseltern
3. **Full Path Compression**: Alle Knoten zeigen direkt auf die Wurzel (rekursiv)
====

== Algorithmus-Analyse im Detail

=== Inverse Ackermann-Funktion α(n)

Die optimierte Union-Find-Implementation erreicht O(α(n)) amortisierte Zeit, wobei α(n) die inverse Ackermann-Funktion ist.

**Praktische Werte von α(n)**:
[cols="2,1"]
|===
|n |α(n)

|16
|3

|65.536
|4

|2^65.536
|5
|===

Für alle praktischen Zwecke ist α(n) ≤ 5, also **quasi-konstant**.

=== Beweisidee der Komplexität

Die Analyse basiert auf dem **Potential-Methoden-Argument**:

1. **Rang-Eigenschaft**: Rang eines Knotens = obere Schranke der Baumhöhe
2. **Path Compression** reduziert zukünftige Kosten
3. **Amortisierte Analyse** über alle Operationen ergibt O(α(n))

.Visualisierung der Path Compression
----
Vor find(7):
    0
   / \
  1   2
 /   / \
3   4   5
       / \
      6   7

Nach find(7) mit Path Compression:
    0
   /|\|
  1 2 7 6
  | |   |
  3 4   5
----

== Praktische Verwendung

=== Beispiel: Netzwerk-Konnektivität

[source,python]
----
def solve_network_connectivity():
    """Löse Netzwerk-Konnektivitätsproblem mit Union-Find."""
    n = 10  # Computer 0-9
    connections = [(0,1), (1,2), (3,4), (5,6), (6,7), (7,8)]
    queries = [(0,2), (3,8), (1,5), (4,6)]

    uf = UF(n)

    # Erstelle Verbindungen
    print("Erstelle Netzwerkverbindungen:")
    for p, q in connections:
        if not uf.connected(p, q):
            uf.union(p, q)
            print(f"Computer {p} und {q} verbunden")

    print(f"\nAnzahl separate Netzwerke: {uf.count()}")

    # Beantworte Konnektivitäts-Anfragen
    print("\nKonnektivitäts-Anfragen:")
    for p, q in queries:
        if uf.connected(p, q):
            print(f"Computer {p} und {q} sind im gleichen Netzwerk")
        else:
            print(f"Computer {p} und {q} sind NICHT verbunden")

# Ausgabe:
# Computer 0 und 1 verbunden
# Computer 1 und 2 verbunden
# Computer 3 und 4 verbunden
# Computer 5 und 6 verbunden
# Computer 6 und 7 verbunden
# Computer 7 und 8 verbunden
#
# Anzahl separate Netzwerke: 5
#
# Computer 0 und 2 sind im gleichen Netzwerk
# Computer 3 und 8 sind NICHT verbunden
# Computer 1 und 5 sind NICHT verbunden
# Computer 4 und 6 sind NICHT verbunden
----

=== Beispiel: Perkolation

[source,python]
----
import random

def percolation_simulation(n, probability=0.6):
    """Simuliere Perkolation auf n×n Grid."""
    grid_size = n * n
    uf = UF(grid_size + 2)  # +2 für virtuelle Top/Bottom-Knoten

    virtual_top = grid_size
    virtual_bottom = grid_size + 1

    def get_index(row, col):
        return row * n + col

    # Öffne Zellen zufällig
    opened = [[False] * n for _ in range(n)]

    for _ in range(int(grid_size * probability)):
        row = random.randint(0, n-1)
        col = random.randint(0, n-1)

        if not opened[row][col]:
            opened[row][col] = True
            current = get_index(row, col)

            # Verbinde mit virtuellen Knoten
            if row == 0:  # Top-Reihe
                uf.union(current, virtual_top)
            if row == n-1:  # Bottom-Reihe
                uf.union(current, virtual_bottom)

            # Verbinde mit Nachbarn
            directions = [(-1,0), (1,0), (0,-1), (0,1)]
            for dr, dc in directions:
                nr, nc = row + dr, col + dc
                if (0 <= nr < n and 0 <= nc < n and
                    opened[nr][nc]):
                    neighbor = get_index(nr, nc)
                    uf.union(current, neighbor)

    # Prüfe Perkolation
    percolates = uf.connected(virtual_top, virtual_bottom)

    print(f"Grid: {n}×{n}, Wahrscheinlichkeit: {probability}")
    print(f"Perkoliert: {'Ja' if percolates else 'Nein'}")
    print(f"Komponenten: {uf.count()}")

    return percolates
----

== Performance-Vergleich

=== Benchmarking verschiedener Implementierungen

[source,python]
----
import time
from typing import List, Tuple

def benchmark_implementations(n: int, operations: List[Tuple[int, int]]):
    """Vergleiche Performance verschiedener Union-Find-Implementierungen."""

    implementations = {
        'Quick Find': QuickFindUF,
        'Quick Union': QuickUnionUF,
        'Weighted QU': WeightedQuickUnionUF,
        'Optimized UF': UF
    }

    results = {}

    for name, UF_class in implementations.items():
        uf = UF_class(n)

        start_time = time.time()

        for p, q in operations:
            uf.union(p, q)

        end_time = time.time()
        results[name] = end_time - start_time

    # Ergebnisse ausgeben
    print(f"Benchmark für {n} Knoten, {len(operations)} union-Operationen:")
    print("-" * 50)

    for name, time_taken in sorted(results.items(), key=lambda x: x[1]):
        print(f"{name:15}: {time_taken:.4f} Sekunden")

# Beispiel-Verwendung:
# random_ops = [(random.randint(0, 999), random.randint(0, 999))
#               for _ in range(10000)]
# benchmark_implementations(1000, random_ops)
----

=== Erwartete Performance-Charakteristiken

[cols="3,2,2,2,2"]
|===
|Szenario |Quick Find |Quick Union |Weighted QU |Optimized UF

|**Kleine Datasets** (n < 100)
|Gut
|Gut
|Gut
|Gut

|**Mittlere Datasets** (n ≈ 1000)
|Langsam
|Variable
|Gut
|Sehr gut

|**Grosse Datasets** (n > 10000)
|Sehr langsam
|Sehr langsam*
|Gut
|Optimal

|**Viele Queries**
|Gut (find = O(1))
|Variable
|Gut
|Optimal

|**Sequenzielle Unions**
|Sehr langsam
|Sehr langsam
|Gut
|Optimal
|===

_*) Kann degenerieren bei ungünstigen Eingabedaten_

== Erweiterte Themen

=== Union-Find mit zusätzlichen Operationen

[source,python]
----
class ExtendedUF(UF):
    """Erweiterte Union-Find mit zusätzlichen Operationen."""

    def __init__(self, n):
        super().__init__(n)
        self._size = [1] * n  # Grösse jeder Komponente

    def union(self, p, q):
        root_p = self.find(p)
        root_q = self.find(q)

        if root_p == root_q:
            return False  # Bereits verbunden

        # Standard union mit size tracking
        if self._rank[root_p] < self._rank[root_q]:
            self._parent[root_p] = root_q
            self._size[root_q] += self._size[root_p]
        elif self._rank[root_p] > self._rank[root_q]:
            self._parent[root_q] = root_p
            self._size[root_p] += self._size[root_q]
        else:
            self._parent[root_q] = root_p
            self._rank[root_p] += 1
            self._size[root_p] += self._size[root_q]

        self._count -= 1
        return True  # Union durchgeführt

    def component_size(self, p):
        """Gibt die Grösse der Komponente zurück, die p enthält."""
        root = self.find(p)
        return self._size[root]

    def largest_component(self):
        """Gibt die Grösse der grössten Komponente zurück."""
        return max(self._size[self.find(i)] for i in range(len(self._parent)))

    def get_components(self):
        """Gibt alle Komponenten als Liste von Listen zurück."""
        components = {}

        for i in range(len(self._parent)):
            root = self.find(i)
            if root not in components:
                components[root] = []
            components[root].append(i)

        return list(components.values())
----

=== Gewichtete Union-Find (mit Werten)

[source,python]
----
class WeightedUF:
    """Union-Find mit gewichteten Verbindungen (für relative Positionen)."""

    def __init__(self, n):
        self._parent = list(range(n))
        self._weight = [0] * n  # weight[i] = Gewicht von i relativ zur Wurzel
        self._count = n

    def find(self, p):
        if p != self._parent[p]:
            # Path compression mit Gewichts-Update
            original_parent = self._parent[p]
            self._parent[p] = self.find(self._parent[p])
            self._weight[p] += self._weight[original_parent]
        return self._parent[p]

    def union(self, p, q, weight):
        """Verbinde p und q mit relativem Gewicht: weight[q] - weight[p] = weight"""
        root_p = self.find(p)
        root_q = self.find(q)

        if root_p == root_q:
            # Prüfe Konsistenz
            expected = self._weight[q] - self._weight[p]
            return abs(expected - weight) < 1e-9

        # Union
        self._parent[root_p] = root_q
        self._weight[root_p] = self._weight[q] - weight - self._weight[p]
        self._count -= 1
        return True

    def difference(self, p, q):
        """Gibt weight[q] - weight[p] zurück, falls verbunden."""
        if not self.connected(p, q):
            return None
        return self._weight[q] - self._weight[p]
----

== Übungsaufgaben

=== Aufgabe 1: Grundlegende Implementation
Implementieren Sie eine Union-Find-Datenstruktur, die folgende Operationen unterstützt:
- `union(p, q)`: Verbinde p und q
- `connected(p, q)`: Sind p und q verbunden?
- `count()`: Anzahl der Komponenten

=== Aufgabe 2: Optimierte Version
Verbessern Sie Ihre Implementation durch:
1. Weighted Union (by size oder rank)
2. Path Compression
3. Messen Sie die Performance-Verbesserung

=== Aufgabe 3: Anwendung - Freunde-Netzwerk
Modellieren Sie ein soziales Netzwerk:
- Personen können Freunde werden (`union`)
- Prüfen Sie, ob zwei Personen im gleichen Freundeskreis sind
- Finden Sie die Grösse des grössten Freundeskreises

=== Aufgabe 4: Anwendung - Labyrinth
Verwenden Sie Union-Find zur Labyrinth-Generierung:
1. Starten Sie mit einem Gitter voller Wände
2. Entfernen Sie zufällig Wände und verbinden Sie Zellen
3. Stoppen Sie, wenn Start und Ziel verbunden sind

=== Aufgabe 5: Erweiterte Analyse
Analysieren Sie die Laufzeit verschiedener Union-Find-Varianten:
1. Implementieren Sie alle vier Versionen
2. Messen Sie die Performance für verschiedene Eingabegrössen
3. Visualisieren Sie die Ergebnisse

[TIP]
====
**Lösungshinweise:**

*Aufgabe 1:* Beginnen Sie mit Quick Find für einfache Implementierung

*Aufgabe 2:* Path Compression kann iterativ oder rekursiv implementiert werden

*Aufgabe 3:* Erweitern Sie UF um `component_size()` Methode

*Aufgabe 4:* Verwenden Sie 2D-Grid-Koordinaten zu 1D-Array-Index Mapping

*Aufgabe 5:* Nutzen Sie Python's `time` Modul für Messungen
====

== Zusammenfassung

Union-Find ist eine elegante und effiziente Lösung für das dynamische Konnektivitätsproblem:

**Kernkonzepte:**
- Partitionierung in disjunkte Mengen
- Äquivalenzrelation (reflexiv, symmetrisch, transitiv)
- Baum-basierte Darstellung mit Optimierungen

**Optimierungen:**
- **Weighted Union**: Verhindert degenerierte Bäume → O(log n)
- **Path Compression**: Flacht Pfade ab → O(α(n)) amortisiert
- **Kombiniert**: Praktisch konstante Zeit für alle Operationen

**Anwendungen:**
- Kruskal's Minimum Spanning Tree
- Perkolationstheorie
- Bildverarbeitung und Segmentierung
- Netzwerk-Konnektivitätsanalyse
- Dynamische Äquivalenzrelationen

[NOTE]
====
**Wichtige Erkenntnisse:**

- Union-Find zeigt, wie einfache Optimierungen dramatische Performance-Verbesserungen bringen können
- Die inverse Ackermann-Funktion α(n) ist ein seltenes Beispiel einer "praktisch konstanten" Funktion
- Die amortisierte Analyse ist entscheidend für das Verständnis der true Performance
====

== Weiterführende Literatur

* **Sedgewick & Wayne**: "Algorithms, 4th Edition" - Kapitel 1.5
* **Cormen et al.**: "Introduction to Algorithms" - Kapitel 21
* **Tarjan**: "Data Structures and Network Algorithms" - Union-Find Analyse
* **Galler & Fisher (1964)**: Originalarbeit zu Union-Find
* **Tarjan (1975)**: Path Compression Analyse

---

_Diese Dokumentation ist Teil des FFHS-DUA Kurses "Algorithmen und Datenstrukturen"_
