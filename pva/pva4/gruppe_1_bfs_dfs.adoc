= Gruppe 1: Breiten- und Tiefensuche (BFS & DFS)
:toc: left
:toclevels: 3
:sectnums:
:source-highlighter: highlightjs

== Überblick

Diese Gruppe behandelt die fundamentalen Traversierungsalgorithmen für Graphen:

* **BFS (Breadth-First Search)**: Schichtweise Erkundung
* **DFS (Depth-First Search)**: Tiefenorientierte Erkundung
* **Topologische Sortierung**: Ordnung für DAGs

== 1. Algorithmen-Erklärung

=== 1.1 Breitensuche (BFS)

**Was macht BFS?**
- Erkundet Graphen schichtweise von einem Startknoten
- Findet kürzeste Pfade in ungewichteten Graphen
- Komplexität: O(V + E)

**Pseudocode:**
[source]
----
BFS(G, s):
  queue = Queue()
  marked[s] = true
  queue.enqueue(s)

  while not queue.is_empty():
    v = queue.dequeue()
    for each edge (v, w) in G.adj[v]:
      if not marked[w]:
        marked[w] = true
        edge_to[w] = v
        queue.enqueue(w)
----

=== 1.2 Tiefensuche (DFS)

**Was macht DFS?**
- Erkundet Graphen rekursiv in die Tiefe
- Findet Pfade und Zusammenhang
- Basis für Topologische Sortierung
- Komplexität: O(V + E)

**Pseudocode:**
[source]
----
DFS(G, v):
  marked[v] = true
  for each edge (v, w) in G.adj[v]:
    if not marked[w]:
      edge_to[w] = v
      DFS(G, w)
----

=== 1.3 Topologische Sortierung

**Was macht Topologische Sortierung?**
- Ordnet Knoten eines DAG linear
- Respektiert alle Abhängigkeiten
- Verwendet DFS mit Postorder-Traversierung
- Komplexität: O(V + E)

**Anwendungen:**
- Task-Scheduling
- Dependency Resolution
- Compiler-Optimierung

== 2. Implementierungen

=== 2.1 BFS in Python

[source,python]
----
from src.algs4.pva_4_graphs import BFS, EdgeWeightedGraph

# Graph laden
with open("data/graphs/tinyEWG.txt") as f:
    g = EdgeWeightedGraph(f)

# BFS von Knoten 0
bfs = BFS(g, 0)

# Pfade abfragen
if bfs.has_path_to(3):
    path = bfs.path_to(3)
    print(f"Pfad: {list(path)}")
    print(f"Distanz: {bfs.distance_to(3)}")
----

=== 2.2 DFS in Python

[source,python]
----
from src.algs4.pva_4_graphs import DFSPaths, EdgeWeightedGraph

# Graph laden
with open("data/graphs/tinyEWG.txt") as f:
    g = EdgeWeightedGraph(f)

# DFS von Knoten 0
dfs = DFSPaths(g, 0)

# Pfade abfragen
if dfs.has_path_to(3):
    path = dfs.path_to(3)
    print(f"Pfad: {list(path)}")
----

=== 2.3 Topologische Sortierung

[source,python]
----
from src.algs4.pva_4_graphs import Topological, EdgeWeightedDigraph, DirectedEdge

# DAG laden
g = EdgeWeightedDigraph(13)
g.add_edge(DirectedEdge(0, 5, 0.0))
g.add_edge(DirectedEdge(0, 1, 0.0))
# ... weitere Kanten

# Topologische Sortierung
topo = Topological(g)

if topo.has_order():
    order = list(topo.order())
    print(f"Topologische Ordnung: {order}")
else:
    print("Graph enthält Zyklus!")
----

== 3. Übungen

=== Übung 1: Pfade in ungerichteten Graphen

**Aufgabe:**
Implementiere eine Funktion, die alle Knoten findet, die von einem Startknoten erreichbar sind.

**Testdaten:** `data/graphs/tinyEWG.txt`

**Erwartetes Ergebnis:**
Von Knoten 0 sind Knoten 1, 2, 3, 4, 5, 6, 7 erreichbar.

=== Übung 2: Topologische Sortierung

**Aufgabe:**
Implementiere eine Funktion, die eine topologische Sortierung eines DAG berechnet.

**Testdaten:** `data/graphs/tinyDAG.txt`

**Erwartetes Ergebnis:**
Eine gültige topologische Ordnung, z.B. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

== 4. Testdaten

[cols="1,1,1,1"]
|===
| Datei | Knoten | Kanten | Verwendung

| tinyEWG.txt | 8 | 16 | BFS/DFS Tests
| tinyDAG.txt | 13 | 22 | Topologische Sortierung
| mediumEWG.txt | 250 | ~1000 | Performance-Tests
|===

== 5. Präsentations-Checkliste

* [ ] Algorithmen erklären (2-3 Min)
* [ ] Live-Demo mit Code (3-4 Min)
* [ ] Ergebnisse zeigen (2-3 Min)
* [ ] Fragen beantworten (1-2 Min)

== 6. Ressourcen

* Buch: Sedgewick & Wayne, Kapitel 4.1-4.2
* Code: `src/algs4/pva_4_graphs/bfs.py`, `dfs_paths.py`, `topological.py`
* Tests: `tests/test_graphs/test_bfs.py`, `test_dfs_paths.py`, `test_topological.py`
