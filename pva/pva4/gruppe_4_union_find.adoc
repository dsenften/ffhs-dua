= Gruppe 4: Union-Find (Disjoint Set Union)
:toc: left
:toclevels: 3
:sectnums:
:source-highlighter: highlightjs

== Überblick

Diese Gruppe behandelt die Union-Find Datenstruktur und ihre Anwendungen:

* **Union-Find Grundlagen**: Datenstruktur für Äquivalenzklassen
* **Optimierungen**: Path Compression und Union by Rank
* **Anwendungen**: Zyklenerkennung, Kruskal's Algorithmus

== 1. Algorithmen-Erklärung

=== 1.1 Union-Find Datenstruktur

**Was macht Union-Find?**
- Verwaltet disjunkte Mengen (Äquivalenzklassen)
- Zwei Operationen: `find()` und `union()`
- Sehr effizient mit Optimierungen
- Komplexität: O(α(n)) amortisiert (α = inverse Ackermann)

**Grundkonzept:**
[source]
----
find(x):
  Finde die Wurzel der Menge, die x enthält

union(x, y):
  Vereinige die Mengen, die x und y enthalten

connected(x, y):
  Prüfe, ob x und y in der gleichen Menge sind
----

=== 1.2 Implementierungsvarianten

**1. Quick Find (naiv)**
- `find()`: O(1)
- `union()`: O(n)
- Schlecht für viele Unions

**2. Quick Union (naiv)**
- `find()`: O(n)
- `union()`: O(n)
- Besser, aber noch nicht optimal

**3. Weighted Quick Union**
- `find()`: O(log n)
- `union()`: O(log n)
- Gute Balance

**4. Weighted Quick Union + Path Compression**
- `find()`: O(α(n))
- `union()`: O(α(n))
- Praktisch konstant!

=== 1.3 Optimierungen

**Path Compression:**
[source]
----
find(x):
  if x != parent[x]:
    parent[x] = find(parent[x])  # Komprimiere Pfad
  return parent[x]
----

**Union by Rank:**
[source]
----
union(x, y):
  root_x = find(x)
  root_y = find(y)

  if rank[root_x] < rank[root_y]:
    parent[root_x] = root_y
  elif rank[root_x] > rank[root_y]:
    parent[root_y] = root_x
  else:
    parent[root_y] = root_x
    rank[root_x] += 1
----

== 2. Implementierungen

=== 2.1 Union-Find in Python

[source,python]
----
from src.algs4.pva_1_fundamentals import UF

# Union-Find mit 10 Elementen
uf = UF(10)

# Unions durchführen
uf.union(0, 1)
uf.union(1, 2)
uf.union(3, 4)

# Verbindungen prüfen
print(uf.connected(0, 2))  # True
print(uf.connected(0, 3))  # False

# Komponenten zählen
print(uf.count())  # 7 Komponenten
----

=== 2.2 Integration in Kruskal

[source,python]
----
from src.algs4.pva_4_graphs import KruskalMST, EdgeWeightedGraph
from src.algs4.pva_1_fundamentals import UF

# Graph laden
with open("data/graphs/tinyEWG.txt") as f:
    g = EdgeWeightedGraph(f)

# Kruskal nutzt Union-Find intern
mst = KruskalMST(g)

# Union-Find wird verwendet zur Zyklenerkennung
print(f"MST-Gewicht: {mst.weight()}")
----

== 3. Übungen

=== Übung 1: Union-Find Operationen

**Aufgabe:**
Implementiere eine Sequenz von Union- und Find-Operationen.

**Beispiel:**
[source]
----
union(0, 1)
union(1, 2)
union(3, 4)
union(4, 5)
union(5, 6)
union(6, 7)
union(7, 8)
union(8, 9)
union(9, 0)

connected(0, 9)?  // True
connected(0, 3)?  // False
----

=== Übung 2: Vergleich der Varianten

**Aufgabe:**
Vergleiche die Performance der 4 Union-Find Varianten.

**Messungen:**
- Laufzeit für 1000 Unions und Finds
- Speicherverbrauch
- Pfadlängen nach Operationen

**Varianten:**
1. Quick Find
2. Quick Union
3. Weighted Quick Union
4. Weighted Quick Union + Path Compression

=== Übung 3: Zyklenerkennung

**Aufgabe:**
Nutze Union-Find zur Zyklenerkennung in einem Graphen.

**Algorithmus:**
[source]
----
has_cycle(G):
  uf = UnionFind(G.V)
  for each edge (v, w) in G.edges():
    if uf.connected(v, w):
      return true  // Zyklus gefunden
    uf.union(v, w)
  return false
----

== 4. Testdaten

[cols="1,1,1"]
|===
| Datei | Verwendung | Größe

| tinyEWG.txt | Basis-Tests | 8 Knoten
| mediumEWG.txt | Performance-Tests | 250 Knoten
| largeEWG.txt | Benchmark | 1000+ Knoten
|===

== 5. Präsentations-Checkliste

* [ ] Union-Find erklären (2-3 Min)
* [ ] Varianten vergleichen (2 Min)
* [ ] Live-Demo mit Code (3-4 Min)
* [ ] Performance-Ergebnisse (2 Min)
* [ ] Integration in Kruskal zeigen (1 Min)
* [ ] Fragen beantworten (1-2 Min)

== 6. Ressourcen

* Buch: Sedgewick & Wayne, Kapitel 1.5
* Code: `src/algs4/pva_1_fundamentals/uf.py`
* Tests: `tests/test_fundamentals/test_uf.py`
