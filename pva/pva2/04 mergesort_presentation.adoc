= MergeSort Algorithmus
:author: Daniel Senften
:revdate: {docdate}
:backend: revealjs
:revealjs_theme: white
:revealjs_transition: slide
:source-highlighter: highlight.js
:icons: font

== MergeSort

* **Divide-and-Conquer Algorithmus**
* **Garantiert**: O(n log n)
* **Stabil**: Reihenfolge gleicher Elemente bleibt erhalten
* Extra Speicher: O(n)

== Grundprinzip

[.step]
* **Teile** Array in zwei H√§lften
* **Sortiere** rekursiv beide H√§lften
* **Verschmelze** sortierte H√§lften

== Divide: Teilen

```python
def mergesort(cls, arr: list, lo: int, hi: int):
    if lo >= hi:
        return arr

    mid = lo + (hi - lo) // 2

    cls.mergesort(arr, lo, mid)      # Erste H√§lfte
    cls.mergesort(arr, mid + 1, hi)  # Zweite H√§lfte
```

[.notes]
--
Quellcode: `src/algs4/sorting/merge.py:74-99`
--

== Conquer: Verschmelzen

```python
def merge(cls, arr: list, lo: int, mid: int, hi: int):
    aux = arr[lo : hi + 1]  # Hilfarray

    i = 0              # Zeiger erste H√§lfte
    j = mid - lo + 1   # Zeiger zweite H√§lfte

    for k in range(lo, hi + 1):
        # Verschmelze die beiden H√§lften
```

== Merge-Prozess

[.step]
. **Kopiere** Bereich in Hilfsarray
. **Vergleiche** Elemente beider H√§lften
. **W√§hle** kleineres Element
. **F√ºge** in Originalarray ein

== Merge-Logik

```python
if i > mid - lo:
    arr[k] = aux[j]        # Erste H√§lfte ersch√∂pft
    j += 1
elif j > hi - lo:
    arr[k] = aux[i]        # Zweite H√§lfte ersch√∂pft
    i += 1
elif aux[i] <= aux[j]:
    arr[k] = aux[i]        # Stabilit√§t!
    i += 1
else:
    arr[k] = aux[j]
    j += 1
```

== Beispiel: [5, 2, 8, 1]

[.step]
* **Teile**: [5, 2] | [8, 1]
* **Sortiere**: [2, 5] | [1, 8]
* **Merge**:
  - Vergleiche 2 vs 1 ‚Üí 1
  - Vergleiche 2 vs 8 ‚Üí 2
  - Vergleiche 5 vs 8 ‚Üí 5
  - Vergleiche - vs 8 ‚Üí 8
* **Ergebnis**: [1, 2, 5, 8]

== Visualisierung

```
     [5, 2, 8, 1]
    /            \
[5, 2]           [8, 1]
  |                |
[2, 5]           [1, 8]
    \            /
     [1, 2, 5, 8]
```

== Hauptmethode

```python
@classmethod
def sort(cls, arr: list) -> list:
    if arr is None:
        return None

    arr_copy = arr.copy()
    cls.mergesort(arr_copy, 0, len(arr_copy) - 1)
    return arr_copy
```

== Komplexit√§t

[.step]
* **Best Case**: O(n log n)
* **Average Case**: O(n log n)
* **Worst Case**: O(n log n)
* **Speicher**: O(n)

**Warum garantiert O(n log n)?**

== Rekursionsbaum

```
Level 0:        n
Level 1:     n/2  n/2
Level 2:   n/4 n/4 n/4 n/4
...
Level log n: 1 1 1 ... 1
```

**Jedes Level**: O(n) Arbeit
**Anzahl Level**: log n

== Eigenschaften

[cols="2*"]
|===
|‚úÖ **Vorteile** |‚ùå **Nachteile**

|Garantiert O(n log n) |Extra Speicher O(n)
|Stabil |Nicht In-Place
|Vorhersagbare Performance |Overhead f√ºr kleine Arrays
|Parallisierbar |Rekursion = Stack-Overhead
|===

== Stabilit√§t

**Wichtig f√ºr komplexe Datentypen:**

```python
students = [
    ("Alice", 85),
    ("Bob", 90),
    ("Charlie", 85)
]
```

Nach Sortierung nach Note:
```python
[("Alice", 85), ("Charlie", 85), ("Bob", 90)]
```

Alice bleibt vor Charlie!

== Implementierung

```
üìÅ src/algs4/sorting/merge.py
üìÅ tests/test_sorting/test_merge.py
```

**Verwendung:**
```python
from src.algs4.sorting import Merge

sorted_array = Merge.sort([5, 2, 8, 1])
```

== Vielen Dank!

**Fragen?**

[.notes]
--
Weitere Details in: `docs/` (Dokumentation folgt)
--
