= HeapSort Algorithmus
:author: Daniel Senften
:revdate: {docdate}
:backend: revealjs
:revealjs_theme: white
:revealjs_transition: slide
:source-highlighter: highlight.js
:icons: font

== HeapSort

* **Heap-basierter Algorithmus**
* **Garantiert**: O(n log n)
* **In-Place**: O(1) extra Speicher
* **Nicht stabil**

== Was ist ein Heap?

[.step]
* **Vollst√§ndiger Bin√§rbaum**
* **Max-Heap**: Eltern ‚â• Kinder
* **Array-Repr√§sentation**:
  - Index i: Kinder bei 2i+1 und 2i+2
  - Index i: Eltern bei (i-1)/2

== Heap-Eigenschaft

```
Array: [9, 7, 6, 2, 1, 4, 5]

       9
     /   \
    7     6
   / \   / \
  2   1 4   5
```

**Max-Heap**: Jeder Knoten ‚â• seine Kinder

== HeapSort Algorithmus

[.step]
. **Heap-Konstruktion**: Array ‚Üí Max-Heap
. **Sortdown**: Wiederhole:
   - Extrahiere Maximum (Wurzel)
   - Repariere Heap

== Phase 1: Heap-Konstruktion

```python
def sort(cls, arr: list) -> list:
    n = len(arr)

    # Heapify: Beginne mit letztem Nicht-Blatt
    k = n // 2 - 1
    while k >= 0:
        cls.sink(arr, k, n - 1)
        k -= 1
```

[.notes]
--
Quellcode: `src/algs4/sorting/heap.py:74-80`
--

== Sink-Operation (Heapify)

```python
def sink(cls, arr: list, i: int, length: int):
    while 2 * i + 1 <= length:
        j = 2 * i + 1           # Linkes Kind

        # W√§hle gr√∂sseres Kind
        if j < length and arr[j] < arr[j + 1]:
            j += 1

        if arr[i] >= arr[j]:    # Heap-Eigenschaft OK
            break

        arr[i], arr[j] = arr[j], arr[i]  # Tausche
        i = j
```

== Phase 2: Sortdown

```python
# Extrahiere Maximum und repariere Heap
while n > 1:
    # Maximum an Ende setzen
    arr[0], arr[n - 1] = arr[n - 1], arr[0]
    n -= 1

    # Heap-Eigenschaft wiederherstellen
    cls.sink(arr, 0, n - 1)
```

== Beispiel: [4, 1, 3, 2, 16, 9, 10]

**Schritt 1: Heapify**
```
[4, 1, 3, 2, 16, 9, 10]
‚Üì
[16, 4, 10, 2, 1, 9, 3]
```

**Heap-Struktur:**
```
      16
    /    \
   4      10
  / \    /  \
 2   1  9    3
```

== Sortdown-Prozess

[.step]
* **Tausche 16 ‚Üî 3**: [3, 4, 10, 2, 1, 9, **16**]
* **Sink 3**: [10, 4, 9, 2, 1, 3, **16**]
* **Tausche 10 ‚Üî 3**: [3, 4, 9, 2, 1, **10, 16**]
* **Sink 3**: [9, 4, 3, 2, 1, **10, 16**]
* ... und so weiter

== Visualisierung

```
Heap-Konstruktion:
[4,1,3,2,16,9,10] ‚Üí [16,4,10,2,1,9,3]

Sortdown:
[16,4,10,2,1,9,3] ‚Üí [10,4,9,2,1,3,16]
[10,4,9,2,1,3,16] ‚Üí [9,4,3,2,1,10,16]
[9,4,3,2,1,10,16] ‚Üí [4,2,3,1,9,10,16]
...
[1,2,3,4,9,10,16]
```

== Komplexit√§t

[.step]
* **Heap-Konstruktion**: O(n)
* **n mal Sortdown**: n √ó O(log n)
* **Gesamt**: O(n log n)

**Warum O(n) f√ºr Heapify?**
Meiste Knoten sind Bl√§tter!

== Heap-Konstruktion: O(n)

```
Level     Knoten    Max-Sink-Tiefe    Arbeit
h           1             h           h
h-1         2           h-1         2(h-1)
h-2         4           h-2         4(h-2)
...        ...           ...          ...
0         2^h             0             0

Gesamt ‚â§ Œ£(i=0 bis h) 2^i √ó (h-i) = O(n)
```

== Eigenschaften

[cols="2*"]
|===
|‚úÖ **Vorteile** |‚ùå **Nachteile**

|Garantiert O(n log n) |Nicht stabil
|In-Place (O(1) Speicher) |Schlechte Cache-Lokalit√§t
|Einfache Implementierung |Konstanter Faktor hoch
|Keine Rekursion |Worst-Case = Average-Case
|===

== Anwendungen

[.step]
* **Priority Queues**
* **Speicherbeschr√§nkte Umgebungen**
* **Embedded Systems**
* **Real-Time Systeme** (vorhersagbare Performance)

== Implementierung

```
üìÅ src/algs4/sorting/heap.py
üìÅ tests/test_sorting/test_heap.py
```

**Verwendung:**
```python
from src.algs4.sorting import Heap

sorted_array = Heap.sort([4, 1, 3, 2, 16, 9, 10])
```

== Vergleich der Algorithmen

[cols="4*"]
|===
|Algorithmus |Best Case |Average |Worst Case

|QuickSort |O(n log n) |O(n log n) |O(n¬≤)
|MergeSort |O(n log n) |O(n log n) |O(n log n)
|**HeapSort** |**O(n log n)** |**O(n log n)** |**O(n log n)**
|===

== Vielen Dank!

**Fragen?**

[.notes]
--
Weitere Details in: `docs/heap_sort_documentation.adoc`
--
